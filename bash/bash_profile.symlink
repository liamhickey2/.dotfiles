# Many exerpts from Andrzej Szelachowski's ~/.bash_profile:

if [ -f ~/.bashrc ]; then . ~/.bashrc; fi

#  Git Bash is started with --login, make sure we still load .bashrc.

DARKGRAY='\[\e[1;30m\]'
LIGHTRED='\[\e[1;31m\]'
GREEN='\[\e[32m\]'
YELLOW='\[\e[1;33m\]'
LIGHTBLUE='\[\e[1;34m\]'
NC='\[\e[m\]'

#  If a colour is to be used in the PS1, it needs to be escaped first as a
#  colour, then as a non-printable character.
#        GRY='\[\e[1:30m\]'
#  Otherwise the shell will not be able to correctly calculate the length
#  of the PS1.

GRY='\[\e[1;30m\]'
RED='\[\e[1;31m\]'
GRN='\[\e[32m\]'
YEL='\[\e[1;33m\]'
BLU='\[\e[1;34m\]'
NC='\[\e[m\]'

#  For "literal" command substitution to be assigned to a variable,
#  use escapes and double quotes:
#        PCT="\` ... \`" . . .
#  Otherwise, the value of PCT variable is assigned only once,
#  when the variable is exported/read from .bash_profile,
#  and it will not change afterwards even if the user ID changes.

#  Escape a variables whose value changes:
#        if [[ \$EUID -eq 0 ]],
#  Otherwise the value of the EUID variable will be assigned only once,
#  as above. 

#  When a variable is assigned, it should be called escaped:
#        echo \$T,
#  Otherwise the value of the T variable is taken from the moment the PCT 
#  variable is exported/read from .bash_profile.
#  So, in this example it would be null.

#  When a variable's value contains a semicolon it should be strong quoted:
#        T='$RED',
#  Otherwise, the semicolon will be interpreted as a command separator.

PS1="\`if [[ \$EUID -eq 0 ]]; then PCT='$RED';
else PCT='$BLU'; fi;
echo '\n$GRN[\w] $GRY('\$PCT'\t$GRY)-('\$PCT'\u$GRY)-('\$PCT'\!$GRY)\n$YEL->$NC '\`"

PS2="$YEL>>$NC "
